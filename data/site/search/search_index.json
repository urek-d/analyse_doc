{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Analyse de donees","text":""},{"location":"#bienvenue","title":"Bienvenue","text":"<p>Ce site explore des techniques avanc\u00e9es d'optimisation et d'analyse des s\u00e9ries temporelles. Nous couvrons des exemples pratiques utilisant des donn\u00e9es r\u00e9elles pour r\u00e9soudre divers probl\u00e8mes dans la vie quotidienne et en entreprise.</p>"},{"location":"#navigation","title":"Navigation","text":"<ul> <li>Analyse des S\u00e9ries Temporelles</li> <li>Optimisation:</li> <li>Optimisation des Inventaires</li> <li>Optimisation des Routes de Livraison</li> <li>Optimisation de la Gestion de Portefeuille</li> <li>Optimisation de la Planification des Projets</li> <li>Optimisation de la Planification de la Production</li> </ul>"},{"location":"Optimisation/inventory_optimization/","title":"Optimisation des Inventaires","text":""},{"location":"Optimisation/inventory_optimization/#introduction","title":"Introduction","text":"<p>L'optimisation des inventaires vise \u00e0 d\u00e9terminer le niveau de stock optimal pour minimiser les co\u00fbts tout en satisfaisant la demande. Les co\u00fbts comprennent les co\u00fbts de maintien des stocks et les co\u00fbts de rupture de stock.</p>"},{"location":"Optimisation/inventory_optimization/#code-explication","title":"Code Explication","text":""},{"location":"Optimisation/inventory_optimization/#importation-des-bibliotheques","title":"Importation des Biblioth\u00e8ques","text":"<p>Nous commen\u00e7ons par importer les biblioth\u00e8ques n\u00e9cessaires.</p> <pre><code>import pandas as pd\nimport numpy as np\nfrom scipy.optimize import minimize\n</code></pre>"},{"location":"Optimisation/inventory_optimization/#generation-de-donnees-fictives","title":"G\u00e9n\u00e9ration de Donn\u00e9es Fictives","text":"<p>Nous g\u00e9n\u00e9rons des donn\u00e9es fictives de demande quotidienne sur un mois</p> <pre><code>np.random.seed(0)\ndemand = np.random.poisson(20, 30)\nholding_cost_per_unit = 0.5\nshortage_cost_per_unit = 10\n</code></pre>"},{"location":"Optimisation/inventory_optimization/#fonction-objectif","title":"Fonction Objectif","text":"<p>Cette fonction calcule le co\u00fbt total en fonction du niveau de stock moyen.</p> <pre><code>def total_cost(stock_level):\n    holding_cost = holding_cost_per_unit * stock_level\n    shortage_days = (demand &gt; stock_level).sum()\n    shortage_cost = shortage_cost_per_unit * shortage_days\n    return holding_cost + shortage_cost\n</code></pre>"},{"location":"Optimisation/inventory_optimization/#optimisation","title":"Optimisation","text":"<p>Nous utilisons minimize pour trouver le niveau de stock qui minimise le co\u00fbt total.</p> <pre><code>\ninitial_guess = [1]\nbounds = [(0, None)]\nsolution = minimize(total_cost, initial_guess, bounds=bounds)\noptimal_stock_level = solution.x[0]\n\nprint(f\"Optimal inventory level: {optimal_stock_level:.2f}\")\n</code></pre>"},{"location":"Optimisation/inventory_optimization/#conclusion","title":"conclusion","text":"<p>Ce mod\u00e8le simple montre comment d\u00e9terminer le niveau de stock optimal pour minimiser les co\u00fbts de maintien et de rupture de stock</p>"},{"location":"Optimisation/job_shop_scheduling/","title":"Optimisation de l'Ordonnancement des T\u00e2ches","text":""},{"location":"Optimisation/job_shop_scheduling/#introduction","title":"Introduction","text":"<p>L'optimisation de l'ordonnancement des t\u00e2ches est un domaine crucial dans la gestion des op\u00e9rations industrielles. Elle permet de d\u00e9terminer l'ordre optimal dans lequel ex\u00e9cuter une s\u00e9rie de t\u00e2ches sur diff\u00e9rentes machines, afin de minimiser le temps total n\u00e9cessaire pour compl\u00e9ter tous les jobs (makespan). </p>"},{"location":"Optimisation/job_shop_scheduling/#pourquoi-utiliser-loptimisation-de-lordonnancement-des-taches","title":"Pourquoi Utiliser l'Optimisation de l'Ordonnancement des T\u00e2ches ?","text":"<p>L'optimisation de l'ordonnancement des t\u00e2ches est utilis\u00e9e pour : - R\u00e9duire les temps de production : En minimisant le makespan, les entreprises peuvent augmenter leur efficacit\u00e9. - Am\u00e9liorer l'utilisation des ressources : En s'assurant que les machines ne restent pas inutilis\u00e9es. - R\u00e9duire les co\u00fbts : En diminuant les d\u00e9lais de production et en optimisant l'utilisation des machines.</p>"},{"location":"Optimisation/job_shop_scheduling/#contexte-dutilisation","title":"Contexte d'Utilisation","text":"<p>L'optimisation de l'ordonnancement des t\u00e2ches est essentielle dans divers secteurs, notamment : - Fabrication : Pour organiser les \u00e9tapes de production sur diff\u00e9rentes machines. - Logistique : Pour planifier les trajets des v\u00e9hicules de livraison. - Informatique : Pour g\u00e9rer l'allocation des t\u00e2ches dans les centres de donn\u00e9es.</p>"},{"location":"Optimisation/job_shop_scheduling/#exemple-reel","title":"Exemple R\u00e9el","text":"<p>Nous allons d\u00e9montrer comment r\u00e9soudre un probl\u00e8me d'optimisation de l'ordonnancement des t\u00e2ches en utilisant des donn\u00e9es simul\u00e9es et la biblioth\u00e8que <code>PuLP</code> de Python.</p>"},{"location":"Optimisation/job_shop_scheduling/#generation-des-donnees","title":"G\u00e9n\u00e9ration des Donn\u00e9es","text":"<p>Nous g\u00e9n\u00e9rons des donn\u00e9es simul\u00e9es pour repr\u00e9senter les jobs, les t\u00e2ches, les machines, et la dur\u00e9e de chaque t\u00e2che.</p> <pre><code>import numpy as np\nimport pandas as pd\n\n# G\u00e9n\u00e9ration des donn\u00e9es\njobs_data = {\n    'Job': [1, 1, 1, 2, 2, 3, 3, 3],\n    'Task': [1, 2, 3, 1, 2, 1, 2, 3],\n    'Machine': ['M1', 'M2', 'M3', 'M2', 'M3', 'M1', 'M3', 'M2'],\n    'Duration': [2, 3, 2, 4, 1, 3, 2, 1]\n}\n\ndf_jobs = pd.DataFrame(jobs_data)\nprint(df_jobs)\n</code></pre> <pre><code>from pulp import LpMaximize, LpProblem, LpVariable, lpSum, PULP_CBC_CMD\n\n# Initialisation du mod\u00e8le\nmodel = LpProblem(name=\"job-shop-scheduling\", sense=LpMaximize)\n\n# D\u00e9finition des variables\ntasks = [(i, j) for i in range(len(df_jobs)) for j in range(i + 1, len(df_jobs))]\nx = LpVariable.dicts(\"x\", tasks, cat=\"Binary\")\nC = LpVariable.dicts(\"C\", range(len(df_jobs)), lowBound=0, cat=\"Continuous\")\n\n# Ajout des contraintes\n# 1. Une t\u00e2che doit \u00eatre ex\u00e9cut\u00e9e apr\u00e8s la t\u00e2che pr\u00e9c\u00e9dente du m\u00eame job\nfor i in range(len(df_jobs)):\n    for j in range(i + 1, len(df_jobs)):\n        if df_jobs.iloc[i]['Job'] == df_jobs.iloc[j]['Job']:\n            model += C[j] &gt;= C[i] + df_jobs.iloc[i]['Duration']\n\n# 2. Une machine ne peut ex\u00e9cuter qu'une seule t\u00e2che \u00e0 la fois\nfor m in df_jobs['Machine'].unique():\n    for t1 in df_jobs[df_jobs['Machine'] == m].index:\n        for t2 in df_jobs[df_jobs['Machine'] == m].index:\n            if t1 &lt; t2:\n                model += C[t2] &gt;= C[t1] + df_jobs.iloc[t1]['Duration'] * x[(t1, t2)]\n                model += C[t1] &gt;= C[t2] + df_jobs.iloc[t2]['Duration'] * (1 - x[(t1, t2)])\n\n# 3. Objectif : minimiser le makespan\nmakespan = LpVariable(\"makespan\", lowBound=0, cat=\"Continuous\")\nmodel += makespan\nfor i in range(len(df_jobs)):\n    model += makespan &gt;= C[i] + df_jobs.iloc[i]['Duration']\n\n# R\u00e9solution du mod\u00e8le\nmodel.solve(PULP_CBC_CMD(msg=0))\n</code></pre>"},{"location":"Optimisation/job_shop_scheduling/#resultats","title":"R\u00e9sultats","text":"<pre><code>print(f\"Optimal Schedule Length: {makespan.value()}\")\nschedule = [(df_jobs.iloc[i]['Job'], df_jobs.iloc[i]['Task'], C[i].value()) for i in range(len(df_jobs))]\nschedule.sort(key=lambda x: x[2])\nfor job in schedule:\n    print(f\"Job {job[0]}, Task {job[1]} starts at time {job[2]:.2f}\")\n</code></pre> <pre><code>Optimal Schedule Length: 20.333333\nJob 1, Task 1 starts at time 0.00\nJob 3, Task 1 starts at time 6.00\nJob 3, Task 2 starts at time 9.00\nJob 3, Task 3 starts at time 11.00\nJob 1, Task 2 starts at time 12.33\nJob 2, Task 1 starts at time 12.33\nJob 2, Task 2 starts at time 16.33\nJob 1, Task 3 starts at time 18.33\n\n</code></pre> <p>L'optimisation de l'ordonnancement des t\u00e2ches est essentielle pour am\u00e9liorer l'efficacit\u00e9 des op\u00e9rations industrielles. En utilisant des techniques de programmation lin\u00e9aire enti\u00e8re et des outils comme PuLP, nous pouvons r\u00e9soudre des probl\u00e8mes complexes d'optimisation dans des contextes r\u00e9els, r\u00e9duire les co\u00fbts et am\u00e9liorer l'utilisation des ressources.</p>"},{"location":"Optimisation/portfolio_optimization/","title":"Optimisation de la Gestion de Portefeuille","text":""},{"location":"Optimisation/portfolio_optimization/#introduction","title":"Introduction","text":"<p>L'optimisation de portefeuille consiste \u00e0 trouver l'allocation optimale des actifs pour maximiser le rendement attendu tout en minimisant le risque.</p>"},{"location":"Optimisation/portfolio_optimization/#code-explication","title":"Code Explication","text":""},{"location":"Optimisation/portfolio_optimization/#importation-des-bibliotheques","title":"Importation des Biblioth\u00e8ques","text":"<p>Nous utilisons <code>pandas</code> pour la manipulation des donn\u00e9es, <code>numpy</code> pour les op\u00e9rations math\u00e9matiques, et <code>cvxopt</code> pour l'optimisation quadratique.</p> <pre><code>import pandas as pd\nimport numpy as np\nfrom cvxopt import matrix, solvers\n</code></pre>"},{"location":"Optimisation/portfolio_optimization/#donnees-de-rendements-historiques","title":"Donn\u00e9es de Rendements Historiques","text":"<p>Nous g\u00e9n\u00e9rons des rendements fictifs pour les actifs.</p> <pre><code>data = {\n    'AAPL': np.random.normal(0.001, 0.02, 100),\n    'GOOG': np.random.normal(0.0012, 0.022, 100),\n}\n\ndf = pd.DataFrame(data)\n</code></pre>"},{"location":"Optimisation/portfolio_optimization/#calcul-des-rendements-moyens-et-de-la-matrice-de-covariance","title":"Calcul des Rendements Moyens et de la Matrice de Covariance","text":"<p>Nous calculons les rendements moyens et la matrice de covariance des rendements.</p> <pre><code>returns = df.mean().values\ncovariances = df.cov().values\n</code></pre>"},{"location":"Optimisation/portfolio_optimization/#matrices-pour-loptimisation-quadratique","title":"Matrices pour l'Optimisation Quadratique","text":"<p>Nous construisons les matrices n\u00e9cessaires pour le solveur quadratique.</p> <pre><code>Q = matrix(covariances)\np = matrix(-returns)\nG = matrix(-np.eye(len(returns)))\nh = matrix(0.0, (len(returns), 1))\nA = matrix(1.0, (1, len(returns)))\nb = matrix(1.0)\n</code></pre>"},{"location":"Optimisation/portfolio_optimization/#resolution","title":"R\u00e9solution","text":"<p>Nous utilisons solvers.qp pour r\u00e9soudre le probl\u00e8me d'optimisation quadratique et obtenir l'allocation optimale du portefeuille.</p> <pre><code>sol = solvers.qp(Q, p, G, h, A, b)\noptimal_portfolio = sol['x']\nprint(f\"Optimal portfolio allocation: {optimal_portfolio}\")\n</code></pre>"},{"location":"Optimisation/portfolio_optimization/#conclusion","title":"Conclusion","text":"<p>Ce mod\u00e8le montre comment optimiser un portefeuille en utilisant des techniques d'optimisation quadratique.</p>"},{"location":"Optimisation/production_planning/","title":"Optimisation de la Planification de la Production","text":""},{"location":"Optimisation/production_planning/#introduction","title":"Introduction","text":"<p>L'objectif est de trouver les niveaux de production optimaux pour minimiser les co\u00fbts tout en satisfaisant la demande. Cela est essentiel pour la gestion de la production industrielle.</p>"},{"location":"Optimisation/production_planning/#code-explication","title":"Code Explication","text":""},{"location":"Optimisation/production_planning/#importation-des-bibliotheques","title":"Importation des Biblioth\u00e8ques","text":"<p>Nous utilisons <code>pandas</code> pour la manipulation des donn\u00e9es, <code>numpy</code> pour les op\u00e9rations math\u00e9matiques, et <code>scipy.optimize</code> pour l'optimisation lin\u00e9aire.</p> <pre><code>import pandas as pd\nimport numpy as np\nfrom scipy.optimize import linprog\n</code></pre>"},{"location":"Optimisation/production_planning/#donnees-de-couts-de-production","title":"Donn\u00e9es de Co\u00fbts de Production","text":"<p>Nous g\u00e9n\u00e9rons des donn\u00e9es fictives de co\u00fbts de production par machine</p> <pre><code>production_costs = np.array([10, 20, 30])\ncapacity_constraints = np.array([100, 100, 100])\ntotal_demand = 250\n</code></pre>"},{"location":"Optimisation/production_planning/#modele-doptimisation-lineaire","title":"Mod\u00e8le d'Optimisation Lin\u00e9aire","text":"<p>Nous utilisons linprog pour r\u00e9soudre le probl\u00e8me d'optimisation lin\u00e9aire et obtenir les niveaux de production optimaux.</p> <pre><code>res = linprog(production_costs, A_ub=[-capacity_constraints], b_ub=[-total_demand], bounds=[(0, None)] * len(production_costs))\nprint(f\"Optimal production levels: {res.x}\")\n</code></pre>"},{"location":"Optimisation/production_planning/#conclusion","title":"Conclusion","text":"<p>Ce mod\u00e8le montre comment optimiser les niveaux de production pour minimiser les co\u00fbts de production tout en satisfaisant la demande. Vous pouvez adapter ce mod\u00e8le \u00e0 vos propres donn\u00e9es de production pour am\u00e9liorer l'efficacit\u00e9 de votre production</p>"},{"location":"Optimisation/project_scheduling/","title":"Optimisation de la Planification des Projets","text":""},{"location":"Optimisation/project_scheduling/#introduction","title":"Introduction","text":"<p>L'optimisation de la planification des projets vise \u00e0 minimiser le temps total n\u00e9cessaire pour terminer un projet en planifiant les t\u00e2ches de mani\u00e8re optimale.</p>"},{"location":"Optimisation/project_scheduling/#code-explication","title":"Code Explication","text":"<p>Precedence (pr\u00e9c\u00e9dence) dans le contexte de l'optimisation de la planification des projets fait r\u00e9f\u00e9rence \u00e0 l'ordre dans lequel les t\u00e2ches doivent \u00eatre effectu\u00e9es. Par exemple, si la t\u00e2che B ne peut commencer qu'apr\u00e8s la fin de la t\u00e2che A, alors A est une t\u00e2che de pr\u00e9c\u00e9dence pour B. Cela signifie que B est d\u00e9pendante de A et que cette d\u00e9pendance doit \u00eatre respect\u00e9e lors de la planification.</p>"},{"location":"Optimisation/project_scheduling/#importation-de-la-bibliotheque","title":"Importation de la Biblioth\u00e8que","text":"<p>Nous utilisons <code>cp_model</code> d'OR-Tools pour la mod\u00e9lisation de contraintes.</p> <pre><code>from ortools.sat.python import cp_model\n</code></pre>"},{"location":"Optimisation/project_scheduling/#donnees-des-taches","title":"Donn\u00e9es des T\u00e2ches","text":"<p>Voici un exemple de donn\u00e9es de t\u00e2ches avec leurs dur\u00e9es et pr\u00e9c\u00e9dences.</p> <pre><code>tasks = {\n    'task1': {'duration': 3, 'precedence': []},\n    'task2': {'duration': 4, 'precedence': ['task1']},\n    'task3': {'duration': 2, 'precedence': ['task2']},\n}\n</code></pre>"},{"location":"Optimisation/project_scheduling/#creation-du-modele","title":"Cr\u00e9ation du Mod\u00e8le","text":"<p>Nous cr\u00e9ons un mod\u00e8le de satisfaction de contraintes avec OR-Tools</p> <pre><code>model = cp_model.CpModel()\n</code></pre>"},{"location":"Optimisation/project_scheduling/#variables-de-debut-de-tache","title":"Variables de D\u00e9but de T\u00e2che","text":"<p>Nous d\u00e9clarons des variables repr\u00e9sentant les moments de d\u00e9but des t\u00e2ches.</p> <pre><code>task_starts = {}\nfor task, data in tasks.items():\n    task_starts[task] = model.NewIntVar(0, 20, task + '_start')\n</code></pre>"},{"location":"Optimisation/project_scheduling/#contraintes-de-precedence","title":"Contraintes de Pr\u00e9c\u00e9dence","text":"<p>Nous ajoutons des contraintes pour s'assurer que les t\u00e2ches respectent les pr\u00e9c\u00e9dences.</p> <pre><code>for task, data in tasks.items():\n    for prec in data['precedence']:\n        model.Add(task_starts[task] &gt;= task_starts[prec] + tasks[prec]['duration'])\n</code></pre>"},{"location":"Optimisation/project_scheduling/#fonction-objectif","title":"Fonction Objectif","text":"<p>Nous d\u00e9finissons l'objectif pour minimiser le makespan</p> <pre><code>makespan = model.NewIntVar(0, 20, 'makespan')\nmodel.AddMaxEquality(makespan, [task_starts[task] + data['duration'] for task, data in tasks.items()])\nmodel.Minimize(makespan)\n</code></pre>"},{"location":"Optimisation/project_scheduling/#resolution","title":"R\u00e9solution","text":"<p>Nous utilisons cp_model.CpSolver pour r\u00e9soudre le mod\u00e8le et obtenir l'ordonnancement optimal.</p> <pre><code>solver = cp_model.CpSolver()\nstatus = solver.Solve(model)\n\nif status == cp_model.OPTIMAL:\n    for task in tasks:\n        print(f\"{task} starts at {solver.Value(task_starts[task])}\")\n    print(f\"Optimal makespan: {solver.Value(makespan)}\")\n</code></pre>"},{"location":"Optimisation/project_scheduling/#conclusion","title":"Conclusion","text":"<p>Ce mod\u00e8le montre comment optimiser la planification des t\u00e2ches pour minimiser le temps total de r\u00e9alisation d'un projet.</p>"},{"location":"Optimisation/route_optimization/","title":"Optimisation des Routes de Livraison","text":""},{"location":"Optimisation/route_optimization/#introduction","title":"Introduction","text":"<p>L'optimisation des routes de livraison, \u00e9galement connue sous le nom de probl\u00e8me du voyageur de commerce (TSP), vise \u00e0 trouver le chemin le plus court pour qu'un v\u00e9hicule visite un ensemble de points et retourne \u00e0 son point de d\u00e9part.</p>"},{"location":"Optimisation/route_optimization/#code-explication","title":"Code Explication","text":""},{"location":"Optimisation/route_optimization/#importation-des-bibliotheques","title":"Importation des Biblioth\u00e8ques","text":"<p>Nous utilisons <code>networkx</code> pour cr\u00e9er et manipuler des graphes, et <code>matplotlib.pyplot</code> pour la visualisation.</p> <pre><code>import networkx as nx\nimport matplotlib.pyplot as \n\n</code></pre>"},{"location":"Optimisation/route_optimization/#donnees-de-distances","title":"Donn\u00e9es de Distances","text":"<p>Voici un exemple de donn\u00e9es de distances entre diff\u00e9rentes villes.</p> <pre><code>distances = {\n    'A': {'B': 10, 'C': 15, 'D': 20},\n    'B': {'A': 10, 'C': 35, 'D': 25},\n    'C': {'A': 15, 'B': 35, 'D': 30},\n    'D': {'A': 20, 'B': 25, 'C': 30},\n}\n</code></pre>"},{"location":"Optimisation/route_optimization/#creation-du-graphe","title":"Cr\u00e9ation du Graphe","text":"<p>Nous cr\u00e9ons un graphe en ajoutant des ar\u00eates entre les villes avec des poids repr\u00e9sentant les distances</p> <pre><code>\nG = nx.Graph()\nfor city, neighbors in distances.items():\n    for neighbor, distance in neighbors.items():\n        G.add_edge(city, neighbor, weight=distance)\n</code></pre>"},{"location":"Optimisation/route_optimization/#resolution-du-tsp","title":"R\u00e9solution du TSP","text":"<p>Nous utilisons l'algorithme d'approximation de networkx pour trouver le chemin optimal.</p> <pre><code>tsp_path = nx.approximation.traveling_salesman_problem(G, cycle=True)\nprint(f\"Optimal path: {tsp_path}\")\n</code></pre>"},{"location":"Optimisation/route_optimization/#visualisation","title":"Visualisation","text":"<p>Nous affichons le graphe avec les distances \u00e9tiquet\u00e9es.</p> <pre><code>pos = nx.spring_layout(G)\nnx.draw(G, pos, with_labels=True, node_size=700, node_color='lightblue')\nlabels = nx.get_edge_attributes(G, 'weight')\nnx.draw_networkx_edge_labels(G, pos, edge_labels=labels)\nplt.show()\n</code></pre>"},{"location":"Optimisation/route_optimization/#conclusion","title":"Conclusion","text":"<p>Ce mod\u00e8le montre comment r\u00e9soudre un probl\u00e8me de route de livraison en utilisant des graphes</p>"},{"location":"timeSeries/time_series_analysis/","title":"Analyse des S\u00e9ries Temporelles","text":""},{"location":"timeSeries/time_series_analysis/#introduction","title":"Introduction","text":"<p>La s\u00e9rie temporelle est une forme de donn\u00e9es o\u00f9 les observations sont collect\u00e9es \u00e0 des intervalles r\u00e9guliers dans le temps. L'analyse des s\u00e9ries temporelles vise \u00e0 extraire des informations significatives sur les comportements pass\u00e9s et \u00e0 utiliser ces informations pour pr\u00e9voir les tendances futures. Cette documentation couvre les concepts de base, les m\u00e9thodologies courantes, leurs applications et fournit une proc\u00e9dure g\u00e9n\u00e9rale pour l'analyse des s\u00e9ries temporelles.</p>"},{"location":"timeSeries/time_series_analysis/#concepts-de-base","title":"Concepts de Base","text":""},{"location":"timeSeries/time_series_analysis/#composantes-dune-serie-temporelle","title":"Composantes d'une S\u00e9rie Temporelle","text":"<ul> <li>Tendance : La direction g\u00e9n\u00e9rale dans laquelle les donn\u00e9es se d\u00e9placent sur une longue p\u00e9riode.</li> <li>Saisonnalit\u00e9 : Les variations p\u00e9riodiques qui se produisent \u00e0 des intervalles fixes (par exemple, saisonnalit\u00e9 mensuelle dans les ventes de No\u00ebl).</li> <li>Cycle : Les variations non p\u00e9riodiques qui peuvent se produire sur de longues p\u00e9riodes, souvent influenc\u00e9es par des facteurs \u00e9conomiques ou soci\u00e9taux.</li> </ul>"},{"location":"timeSeries/time_series_analysis/#stationnarite","title":"Stationnarit\u00e9","text":"<p>Une s\u00e9rie temporelle est dite stationnaire si ses propri\u00e9t\u00e9s statistiques telles que la moyenne et la variance sont constantes dans le temps. Cela facilite l'application de nombreux mod\u00e8les statistiques.</p>"},{"location":"timeSeries/time_series_analysis/#autocorrelation","title":"Autocorr\u00e9lation","text":"<p>La corr\u00e9lation d'une s\u00e9rie temporelle avec une version d\u00e9cal\u00e9e d'elle-m\u00eame. Les fonctions d'autocorr\u00e9lation (ACF) et d'autocorr\u00e9lation partielle (PACF) aident \u00e0 identifier les d\u00e9calages significatifs pour les mod\u00e8les ARIMA.</p>"},{"location":"timeSeries/time_series_analysis/#series-temporelles-multivariees","title":"S\u00e9ries Temporelles Multivari\u00e9es","text":""},{"location":"timeSeries/time_series_analysis/#introduction_1","title":"Introduction","text":"<p>Une s\u00e9rie temporelle multivari\u00e9e est compos\u00e9e de plusieurs s\u00e9ries temporelles observ\u00e9es simultan\u00e9ment. Elle permet de capturer les relations entre diff\u00e9rentes variables tout en tenant compte des d\u00e9pendances temporelles.</p>"},{"location":"timeSeries/time_series_analysis/#concepts-specifiques","title":"Concepts Sp\u00e9cifiques","text":"<ul> <li>Relations Inter-Variables : Les interactions entre les variables \u00e0 un instant donn\u00e9.</li> <li>Causalit\u00e9 de Granger : Technique permettant d'identifier si une variable aide \u00e0 pr\u00e9dire une autre.</li> <li>D\u00e9pendances Crois\u00e9es : Les mod\u00e8les doivent capturer les interd\u00e9pendances entre variables, en plus des d\u00e9pendances temporelles.</li> </ul>"},{"location":"timeSeries/time_series_analysis/#methodologies-specifiques","title":"M\u00e9thodologies Sp\u00e9cifiques","text":""},{"location":"timeSeries/time_series_analysis/#modeles-var-vector-autoregression","title":"Mod\u00e8les VAR (Vector AutoRegression)","text":"<p>Les mod\u00e8les VAR pr\u00e9disent chaque variable en fonction de ses valeurs pass\u00e9es et des valeurs pass\u00e9es des autres variables.</p>"},{"location":"timeSeries/time_series_analysis/#modeles-lstm-multivaries","title":"Mod\u00e8les LSTM Multivari\u00e9s","text":"<p>Les r\u00e9seaux LSTM permettent de capturer des relations complexes entre variables et dans le temps.</p>"},{"location":"timeSeries/time_series_analysis/#modeles-avec-attention","title":"Mod\u00e8les avec Attention","text":"<p>Les m\u00e9canismes d'attention identifient les variables ou s\u00e9quences temporelles les plus importantes pour la pr\u00e9diction.</p>"},{"location":"timeSeries/time_series_analysis/#methodologies-et-techniques","title":"M\u00e9thodologies et Techniques","text":""},{"location":"timeSeries/time_series_analysis/#decomposition-de-saisonnalite","title":"D\u00e9composition de Saisonnalit\u00e9","text":"<p>Technique pour s\u00e9parer une s\u00e9rie temporelle en ses composantes de tendance, saisonnalit\u00e9 et r\u00e9sidus afin de mieux comprendre les motifs sous-jacents.</p>"},{"location":"timeSeries/time_series_analysis/#modeles-arima-autoregressive-integrated-moving-average","title":"Mod\u00e8les ARIMA (AutoRegressive Integrated Moving Average)","text":"<p>Utilis\u00e9s pour mod\u00e9liser des s\u00e9ries temporelles stationnaires. ARIMA comprend trois parties : la partie autor\u00e9gressive (AR), la partie int\u00e9gr\u00e9e (I) et la partie moyenne mobile (MA). Les param\u00e8tres (p, d, q) d\u00e9terminent le nombre de termes AR, les diff\u00e9rences n\u00e9cessaires pour rendre la s\u00e9rie stationnaire, et le nombre de termes MA.</p>"},{"location":"timeSeries/time_series_analysis/#reseaux-de-neurones-recurrents-rnn-et-lstm","title":"R\u00e9seaux de Neurones Recurrents (RNN) et LSTM","text":"<p>Utilis\u00e9s pour capturer les d\u00e9pendances s\u00e9quentielles dans les donn\u00e9es, adapt\u00e9s lorsque les donn\u00e9es pr\u00e9sentent des d\u00e9pendances complexes dans le temps.</p>"},{"location":"timeSeries/time_series_analysis/#applications-et-utilisations","title":"Applications et Utilisations","text":""},{"location":"timeSeries/time_series_analysis/#previsions","title":"Pr\u00e9visions","text":"<p>L'objectif principal de l'analyse des s\u00e9ries temporelles est de faire des pr\u00e9visions pr\u00e9cises sur les valeurs futures, ce qui est crucial pour la planification strat\u00e9gique et la gestion des ressources.</p>"},{"location":"timeSeries/time_series_analysis/#detection-danomalies","title":"D\u00e9tection d'Anomalies","text":"<p>Identifier des comportements inattendus ou des \u00e9v\u00e9nements rares qui se produisent dans la s\u00e9rie temporelle, comme les fraudes financi\u00e8res ou les pannes de syst\u00e8me.</p>"},{"location":"timeSeries/time_series_analysis/#analyse-multivariee","title":"Analyse Multivari\u00e9e","text":"<p>Dans un contexte multivari\u00e9, l'analyse peut inclure : - Pr\u00e9vision des ventes : Utilisation des donn\u00e9es de marketing, m\u00e9t\u00e9o et historiques. - Suivi de performance : Analyse de KPI multiples dans une organisation.</p>"},{"location":"timeSeries/time_series_analysis/#procedure-generale-danalyse-des-series-temporelles","title":"Proc\u00e9dure G\u00e9n\u00e9rale d'Analyse des S\u00e9ries Temporelles","text":""},{"location":"timeSeries/time_series_analysis/#collecte-et-exploration-des-donnees","title":"Collecte et Exploration des Donn\u00e9es","text":"<p>Identifier la s\u00e9rie temporelle \u00e0 analyser, collecter les donn\u00e9es pertinentes et explorer visuellement les tendances et les motifs.</p>"},{"location":"timeSeries/time_series_analysis/#pretraitement","title":"Pr\u00e9traitement","text":"<ul> <li>Assurer la stationnarit\u00e9 des donn\u00e9es en appliquant des transformations comme la diff\u00e9renciation ou en ajustant pour la saisonnalit\u00e9.</li> <li>Dans le cas multivari\u00e9, v\u00e9rifier les corr\u00e9lations entre variables.</li> </ul>"},{"location":"timeSeries/time_series_analysis/#modelisation","title":"Mod\u00e9lisation","text":"<p>Choisir un mod\u00e8le appropri\u00e9 en fonction des caract\u00e9ristiques identifi\u00e9es (ARIMA, VAR, LSTM, etc.).</p>"},{"location":"timeSeries/time_series_analysis/#validation-du-modele","title":"Validation du Mod\u00e8le","text":"<p>Diviser les donn\u00e9es en ensembles d'entra\u00eenement et de test, ajuster le mod\u00e8le sur l'ensemble d'entra\u00eenement, \u00e9valuer les performances sur l'ensemble de test.</p>"},{"location":"timeSeries/time_series_analysis/#prevision-et-evaluation","title":"Pr\u00e9vision et \u00c9valuation","text":"<p>G\u00e9n\u00e9rer des pr\u00e9visions pour les donn\u00e9es futures, \u00e9valuer la pr\u00e9cision du mod\u00e8le en utilisant des m\u00e9triques telles que l'erreur quadratique moyenne (MSE) ou le coefficient de d\u00e9termination (R\u00b2).</p>"},{"location":"timeSeries/time_series_analysis/#conclusion","title":"Conclusion","text":"<p>L'analyse des s\u00e9ries temporelles, univari\u00e9es ou multivari\u00e9es, est essentielle dans de nombreux domaines, de la finance \u00e0 la m\u00e9t\u00e9orologie, en passant par la sant\u00e9 et la gestion des op\u00e9rations. Les s\u00e9ries multivari\u00e9es, en particulier, permettent de capturer des relations complexes, augmentant ainsi la pr\u00e9cision des mod\u00e8les et la valeur des insights obtenus.</p>"}]}